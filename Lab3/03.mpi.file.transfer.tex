\documentclass[a4paper,12pt]{article}

\usepackage{graphicx} % for including images
\usepackage{amsmath}  % for mathematical formulas
\usepackage{hyperref} % for hyperlinks
\usepackage{caption}  % for captioning tables and figures

\title{Practical Work 3: MPI File Transfer}
\author{Dang Quang Minh - 23BI14304}
\date{December 1, 2025}

\begin{document}

\maketitle

\section{Introduction}
In this report, we describe the process of upgrading a TCP-based file transfer system into a file transfer system using the Message Passing Interface (MPI). This system was designed and implemented in parallel, utilizing the MPI library for communication between processes. The purpose of this work is to explore how MPI can facilitate efficient data exchange in a distributed system environment and to learn the practical implementation of MPI in file transfer applications.

\section{Choice of MPI Implementation}
For this project, we decided to use the \texttt{mpicc} compiler and the \texttt{OpenMPI} library as our MPI implementation. OpenMPI is a popular open-source implementation of the MPI standard that supports a variety of environments and platforms. We chose OpenMPI because:

\begin{itemize}
    \item \textbf{Portability:} OpenMPI supports a wide range of systems, including Linux and macOS, making it suitable for use across different platforms.
    \item \textbf{Performance:} OpenMPI is optimized for high performance in parallel computing, which is essential for our file transfer application.
    \item \textbf{Ease of Use:} The API is well-documented, and \texttt{mpicc} simplifies the compilation of MPI programs.
\end{itemize}

\section{System Design}
In this section, we present how the MPI-based file transfer system was designed. The design involves two main processes: one acting as the sender (Rank 0) and the other as the receiver (Rank 1). These processes communicate via MPI message passing to transfer the file from the sender to the receiver.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{System_design.png}
    \caption{System Design Overview}
    \label{fig:system_design}
\end{figure}

\subsection{Rank 0 (Sender)}
The sender process opens the input file (e.g., \texttt{input.bin}), reads it in chunks, and sends the chunks over to Rank 1. The communication happens in two stages:
\begin{enumerate}
    \item The sender first sends the number of bytes to be transferred (this is done to facilitate the correct allocation of memory on the receiver side).
    \item The sender sends the data chunk itself.
\end{enumerate}

Once the entire file is sent, the sender sends a special "end" message, signaling the receiver to stop receiving data.

\subsection{Rank 1 (Receiver)}
The receiver process waits for data from the sender. It repeatedly receives the chunk size, then receives the data itself, and writes the data to the output file. The process stops once it receives the "end" message.

\section{System Organization}
The system is designed to run with exactly two processes: one acting as the sender (Rank 0) and one as the receiver (Rank 1). The sender reads a file, breaks it into manageable chunks, and transmits those chunks to the receiver. The receiver reconstructs the file by writing the received chunks to a new output file.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{System_organization.png}
    \caption{System Organization}
    \label{fig:system_organization}
\end{figure}

\section{Implementation Details}
Here we provide a code snippet that demonstrates the implementation of the file transfer.

\subsection{Code for Rank 0 (Sender)}
The sender process in the program reads the file in chunks and sends it over to Rank 1.

\begin{verbatim}
if (rank == 0) {
    // Rank 0 = Sender
    // -------------------------------
    FILE* f = fopen("input.bin", "rb");
    if (!f){
        perror("Cannot open input.bin");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    int bytes;
    while ((bytes = fread(buffer, 1, CHUNK, f))>0){
        MPI_Send(&bytes, 1, MPI_INT, 1, TAG_DATA, MPI_COMM_WORLD);
        MPI_Send(buffer, bytes, MPI_BYTE, 1, TAG_DATA, MPI_COMM_WORLD);
    }

    // End-of-file message
    int zero = 0;
    MPI_Send(&zero, 1, MPI_INT, 1, TAG_END, MPI_COMM_WORLD);

    fclose(f);
    printf("[Rank 0] File sent successfully\n");
}
\end{verbatim}

\subsection{Code for Rank 1 (Receiver)}
The receiver process in the program waits to receive chunks of data from Rank 0 and writes it to an output file.

\begin{verbatim}
else if (rank == 1){
    // Rank 1 = Receiver
    // -------------------------------
    FILE* f = fopen("output.bin", "wb");
    if (!f){
        perror("Cannot open output.bin");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    int bytes;
    MPI_Status status;

    while (1){
        MPI_Recv(&bytes, 1, MPI_INT, 0, MPI_ANY_TAG, MPI_COMM_WORLD, &status);

        if (status.MPI_TAG == TAG_END)
            break;

        MPI_Recv(buffer, bytes, MPI_BYTE, 0, TAG_DATA, MPI_COMM_WORLD, &status);
        fwrite(buffer, 1, bytes, f);
    }

    fclose(f);
    printf("[Rank 1] File received successfully\n");
}
\end{verbatim}

\section{Conclusion}
In this work, we successfully implemented a file transfer system using MPI. By dividing the task into two processes—one for sending data and one for receiving data—we achieved an efficient method for transferring large files between processes in a distributed system. This exercise demonstrated the practical use of MPI for inter-process communication and data transfer in parallel computing environments.

\end{document}
